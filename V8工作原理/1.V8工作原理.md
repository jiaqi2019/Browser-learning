## 一、编译和解释

### 1 编译器和解释器

都是为了将代码翻译为机器可以读懂的`机器语言`

### 2 编译型和解释性语言

按语言的执行流程，可以把语言划分为`编译型语言`和`解释型语言`

#### 编译型语言

- 在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了
- 如：C/C++、GO

#### 解释型语言

- 每次运行时都需要通过解释器对程序进行动态解释和执行。
- 如 Python、JavaScript 等都属于解释型语言。

### 3 编译和解释流程

<img src="H:\前端\浏览器学习\imgs\4e196603ecb78188e99e963e251b9781.png" style="zoom: 67%;" />

## 二、V8执行js代码



### 0 总体执行流程

<img src="H:\前端\浏览器学习\imgs\1af282bdc4036096c03074da53eb84ae.png" style="zoom: 67%; " />

- 生成抽象语法树（AST）和执行上下文
- 生成字节码
- 执行代码

### 1 生成抽象语法树（AST）和执行上下文

> AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。如著名项目 Babel、ESLint。
>
> Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。
>
> ESLint 检查 JavaScript 编写规范。其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。

**参与者**：

- V8引擎：从头到尾负责整个编译及执行过程
- 编译器

**过程**：

- AST生成 （编译器干的事：此处只涉及Ignition解释器）
  - 词法分析(tokenize) : 生成token流（集合）
  - 语法分析(parse)： 根据js语法将token流转为 AST  
- 执行上下文生成
  - V8（根据AST），生成该段代码的执行上下文



### 2 生成字节码

**参与者**:  V8引擎, 编译器（Ignition）

**过程**：

- 解释器 Ignition根据 AST 生成字节码

**相关概念**：

- 字节码就是介于 AST 和机器码之间的一种代码。
- 但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

**历史原因**：（为什么使用字节码）

因为字节码比机器码占用内存小的多，可以减少系统的内存使用。

> 其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器



### 3 执行代码

**参与者**：V8引擎，解释器 Ignition、编译器 TurboFan

**过程**：

​	字节码需要通过解释器将其转换为机器码后才能执行，所以

- 解释器 Ignition解释执行字节码（逐条执行）
- 执行过程发现有`热点代(字节)码（HotSpot）`，编译器 TurboFan 会将其**编译为**高效的**机器码**，以备下次使用
  - 比如一段代码被重复执行多次，

**相关技术**：**即时编译（JIT）**

- 字节码配合解释器和编译器是最近一段时间很火的技术，这种技术称为**即时编译（JIT）**。
- 如 Java 和 Python 的虚拟机也都是基于这种技术实现的，



## 三 js性能优化

随着V8的优化，对于js执行效率的优化，目前主要聚焦在**单词脚本的执行时间和脚本的网络下载上**，主要关注以下三点

- 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
- 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程。（同步脚本尽量内敛，尽量小）
- 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存

## 四、一些思考

以上每个过程都是编译的一部分，包括解释为字节码，编译器将字节码编译为机器码

当一段代码被执行时，JavaScript 引擎才会对其进行编译，并创建执行上下文。

### 1. 编译的基本单位

js文件或 函数

如下载完一个js文件，先编译这个js文件(经解释器生成字节码——可执行代码，执行上下文)，但文件内定义的函数是不会编译的

等调**用到该函数**的时候，js引擎**才会编译该函数**

### 2. 编译发生的时间

大部分情况下，编译发生在代码执行前的几微秒（甚至更短）

### 3. 什么样的代码才会在执行前编译并创建执行上下文

当一段代码被执行时，JavaScript 引擎才会对其进行编译，并创建执行上下文。这里的一段包括：

- 当 JavaScript 执行**全局代码**的时候，会编译全局代码并创建全局执行上下文，
  - 而且在**整个页面的生存周期内，全局执行上下文只有一份**
- 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，
  - 一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- 使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文







