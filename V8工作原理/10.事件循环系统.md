# 事件循环系统——渲染进程如何调用其中的任务



每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。需要一个系统来统筹调度这些任务，这个统筹调度系统就是**消息队列和事件循环系统。**

<img src="https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png" style="zoom: 50%;" />

## 1 渲染进程中主线程处理进程中其他线程的任务

- 将其他线程产生的任务添加到消息队列的尾部
- 渲染主线程会循环地从消息队列头部中读取任务，执行任务



## 2 渲染进程处理其他进程的任务

渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，



## 3. 消息队列中的任务类型

- 内部消息类型：
  - 输入事件（鼠标滚动、点击、移动）、	
  - 微任务、
  - 文件读写、
  - WebSocket、
  - JavaScript 定时器等等。

- 页面相关事件
  - JavaScript 执行、
  - 解析 DOM、
  - 样式计算、
  - 布局计算、
  - CSS 动画等。

## 4 如何安全退出

当页面主线程（渲染进程主线程）执行完成之后，又该如何保证页面主线程能够安全退出呢？

chrome 是这样解决的，确定要退出当前页面时，页面主线程（渲染进程主线程）会设置一个退出标志的变量，**在每次执行完一个任务时，判断是否有设置退出标志**。

如果设置了，那么就直接中断当前的所有任务，退出线程



## 5 宏任务和微任务的诞生

### 1）如何处理优先级

- 渲染进程 单线程执行消息队列中的任务
- 比如一个任务：监听DOM变化，实现方式：
  - 同步：使用观察者模式，监听到就调用执行，同步任务，由于DOM变化频繁，**导致效率下降**
  - 异步：任务加入到消息队列尾部，又会**影响实时性**

于是诞生了**微任务**

- 把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，
  - 在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。
- 等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，
  - 因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。



### 2）如何解决单个任务执行时长过久的问题。

通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。至













