# 渲染流程四：分层和图层绘制

[TOC]

有了布局树，还不能开始绘制页面，因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了方便实现这些效果，需要分层

## 分层

**渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）**

输入：布局树

输出：图层树

参与：渲染主线程

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面

**图层生成规则**

- **拥有层叠上下文属性的元素会被提升为单独的一层**。
  - https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
  - 常用：明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性
  - 层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上
  - **在层叠上下文中，子元素同样也按照上面解释的规则进行层叠。 重要的是，其子级层叠上下文的 `z-index` 值只在父级中才有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元**。
- **需要剪裁（clip）的地方也会被创建为图层**。
  - 裁剪：div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域
  - 出现这种裁剪情况的时候，**渲染引擎会为文字部分单独创建一个层**，**如果出现滚动条，滚动条也会被提升为单独的层。**
- 元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。



## 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

输入：图层树

输出：绘制（指令）列表，记录绘制顺序和绘制指令的列表

参与：渲染主线程

渲染引擎会把一个图层的绘制拆分成很多小的**绘制指令**，然后再把这些指令按照顺序组成一个**待绘制列表**

绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制



## 栅格化（raster）操作——生成位图

实际上绘制操作是由渲染引擎中的**合成线程**来完成的，

输入：绘制列表

输出：位图

当图层的绘制列表准备好之后，**主线程**会把**该绘制列表提交**（commit）给**合成线程**，

<img src="https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png" style="zoom:50%;" />

把用户可以看到的这个部分叫做**视口**（viewport）。

有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

**具体步骤**：

- **基于以上原因，合成线程会将图层划分为图块（tile）**
- **合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图**，即根据绘制列表把每个图层转换为图片
- 图块中包含了多个图层，每个图层都会生成对应的图片，
- 图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，如下图
- 栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

<img src="https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png" style="zoom: 33%;" /><img src="https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png" style="zoom: 33%;" />





## 合成和显示

- 合成线程会将多个图层对应的图片合成为一张图片，发送到后缓冲区

- 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提**交给浏览器进程**。
- **浏览器进程里面有一个叫 viz 的组件**，用来接收合成线程发过来的 DrawQuad 命令，然后**根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上**

<img src="https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png" style="zoom:50%;" />

















