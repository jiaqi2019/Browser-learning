# 如何系统的优化页面

如果我们要讨论页面优化，就要分析一个页面生存周期的不同阶段。

通常一个页面有三个阶段：**加载阶段、交互阶段和关闭阶段**。

- 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
- 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
- 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。

**重点关注加载阶段和交互阶段**



## 加载阶段

![](https://static001.geekbang.org/resource/image/5d/7b/5d8716586b5f4d719097dca881007a7b.jpg)

并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的

**这些能阻塞网页首次渲染的资源称为关键资源**

那么影响因素为：

- **关键资源个数**
- **关键资源大小**
- **请求关键资源需要多少个 RTT**（Round Trip Time）。
  - 比如文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。
  - 通常 1 个 HTTP 的数据包在 14KB 左右，

**优化**

总的优化原则就是**减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。**

- 减少关键资源的个数
  - 将 JavaScript 和 CSS 改成内联的形式
  - 如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；**变为非关键资源**
  - 对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。或者**动态导入**
- 减少关键资源的大小
  - 压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容
- 减少关键资源 RTT 的次数
  - 减少关键资源的个数和减少关键资源的大小搭配来实现
  - **还可以使用 CDN 来减少每次 RTT 时长。**



## 交互阶段

交互阶段的优化，其实就是在谈**渲染进程渲染帧的速度**

在交互阶段**没有了**加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。

交互阶段的渲染流水线（如下图）

![](https://static001.geekbang.org/resource/image/4a/0c/4a942e53f9358c9c4634c310335cc10c.png)

**大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。**



**优化**

一个大的原则就是让单个帧的生成速度变快。

- **减少 JavaScript 脚本执行时间**
  - 将一次执行的函数分解为多个任务
  - 另一种是采用 Web Workers。把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。
- **避免强制同步布局**
  - 正常情况下的布局操作。通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，（浏览器的优化）
  - **所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。**
  - 如main_div.offsetHeight
  - 
- **避免布局抖动**
  -  所谓布局抖动，是**指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作**
  - 如：在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局
- **合利用 CSS 合成动画**
  - 合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。
  - 尽量**利用好 CSS 合成动画**，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。
  - 如果能提前知道对某个元素执行动画操作，那就最好将其标记为 **will-change**，这是告诉渲染引擎需要将该元素单独生成一个图层。
- **避免频繁的垃圾回收**
  - 尽可能优化储存结构，尽可能避免小颗粒对象的产生
  - 如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。





